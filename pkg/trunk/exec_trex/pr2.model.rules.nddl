/*
 * pr2.rules.nddl
 * Copyright (c) 2008, Willow Garage, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <ORGANIZATION> nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * All behaviors will oscillate between active and inactive
 */
Behavior::Inactive{
	met_by(Active);
	meets(Active);
}

Behavior::Active{
	met_by(Inactive);
	meets(Inactive);
}

Navigator::Going{
	// If the target is bound then generate behavior to accomplish goal
	if(x){
		if(y){
			ends(Actions.Go a);
			eq(a.x, x);
			eq(a.y, y);
			contains a;
		}
	}
}

Actions::Go{
	// If we have a meaningful distance to travel, get going
	starts(VehicleState.Holds initialPos);
	float distanceToGo;
	calcDistance(distanceToGo, initialPos.x, initialPos.y, x, y);
	bool done;
	testLEQ(done, distanceToGo, POSITION_ERROR);
	if(done == false){
		ends(WaypointController.Active wpc);
		contains wpc;
		eq(wpc.x, x);
		eq(wpc.y, y);
	}

	// Force termination
	if(done == true){
		eq(duration, 1);
	}

	// When it ends, check the end conditions.
	ends(VehicleState.Holds vs);
	float delta;
	calcDistance(delta, vs.x, vs.y, x, y);

	// Just constrain the vehicle to be within the expected error of position
	leq(delta, POSITION_ERROR);
}